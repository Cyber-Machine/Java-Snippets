{
	"Array Input":{
		"prefix" : "fra",
		"body" : [
			"for(int i = 0 ; i < n ; i++){",
			"\ta[i]=fr.next${1:Int}();",
			"}"
		],
		"description": "Takes Array input from the user"
		
	},

	"HashMap Push And Pop":{
		"prefix": "MapPushPop",
		"body": [
			"public static void push(HashMap<Integer,Integer> map , Integer val)",
			"{" ,
			"\tif(map.containsKey(val))",
			"\t\tmap.put(val, map.get(val)+1);",
			"\telse",
			"\t\t{",
			"\t\t\tmap.put(val, 1);",
			"\t\t}",
			"}",
			"public static void delete(HashMap<Integer,Integer> map, int key)",
			"{",
			"\tif(map.get(key)>1)",
			"\t\tmap.put(key, map.get(key)-1);",
			"\telse",
			"\t\t{",
			"\t\t\tmap.remove(key);",
			"\t\t}",
			"}"
		],
		"description": "Functions for entering and deleting element from HashMap"
	},
	"Union Find" :{
		"prefix": "UnionFind",
		"body": [
			"public static class UnionFind {",
				"int[] p, rank, setSize;",
				"int numSets;",

				"public UnionFind(int N) {",
				"\tp = new int[numSets = N];",
				"\trank = new int[N];",
				"\tsetSize = new int[N];",
				"\tfor (int i = 0; i < N; i++) {",
				"\t\tp[i] = i;",
				"\t\tsetSize[i] = 1;",
				"\t}",
				"}",
		 
				"public int findSet(int i) {",
				"\treturn p[i] == i ? i : (p[i] = findSet(p[i]));",
				"}",
		 
				"public boolean isSameSet(int i, int j) {",
				"\treturn findSet(i) == findSet(j);",
				"}",
		 
				"public void unionSet(int i, int j) {",
				"\tif (isSameSet(i, j))",
				"\t\treturn;",
				"\tnumSets--;",
				"\tint x = findSet(i), y = findSet(j);",
				"\tif (rank[x] > rank[y]) {",
				"\t\tp[y] = x;",
				"\t\tsetSize[x] += setSize[y];",
				"\t} else {",
				"\t\tp[x] = y;",
				"\t\tsetSize[y] += setSize[x];",
				"\t\tif (rank[x] == rank[y]) rank[y]++;",
				"\t}",
				"}",
		 
				"public int numDisjointSets() {",
				"\treturn numSets;",
				"}",
		 
				"public int sizeOfSet(int i) {",
				"\treturn setSize[findSet(i)];",
				"}",
			"}"
		],
		"description": "Disjoint Union Set"
	},
	"Template" : {
		"prefix": "Template",
		"body": [
			"import java.util.*;",
			"import static java.lang.Math.*;",
			"import java.io.*;",
			"import java.math.*;\n",
			
			"public class Main{\n",
			
			"\tpublic static void main(String[] args) {",
			"\t\tFastReader fr = new FastReader();",
			"\t\tPrintWriter out = new PrintWriter(System.out);",
			"\t\tScanner sc= new Scanner (System.in);",
			"\t\tStringBuilder answer = new StringBuilder();",
			"\t\t// TestCases ",
			"\t\tint TestCases = fr.nextInt();",
			"\t\t//Code From Here",
			"\t\tfor (int TestCase = 1; TestCase <=TestCases; TestCase++){", 
			"\t\t\t ${0:int n = fr.nextInt();} ",
			"\t\t}",
			"\t\tout.println(answer.toString());",
			"\t\tout.flush();",
			"\t\tsc.close();",
			"\t}\n\n\n\n",
			
			
			
			
				
			"\tstatic class FastReader {",
			"\t\tBufferedReader br;",
			"\t\tStringTokenizer st;",
			"\t",
			"\t\tpublic FastReader()",
			"\t\t{",
			"\t\t\tbr = new BufferedReader(",
			"\t\t\tnew InputStreamReader(System.in));",
			"\t\t\t}",
			"\t",
			"\t\t\tString next()",
			"\t\t{",
			"\t\t\twhile (st == null || !st.hasMoreElements()) {",
			"\t\t\t\t try {",
			"\t\t\t\t\tst = new StringTokenizer(br.readLine());",
			"\t\t\t\t}",
			"\t\t\t\tcatch (IOException e) {",
			"\t\t\t\t\te.printStackTrace();",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t\treturn st.nextToken();",
			"\t\t}",
			"\t",
			"\t\t int nextInt() { return Integer.parseInt(next()); }",
			"\t",
			"\t\tlong nextLong() { return Long.parseLong(next()); }",
			"\t",
			"\t\tdouble nextDouble(){ return Double.parseDouble(next()); }",
			"\t",
			"\t\tint[] readArray(int n) {",
			"\t\t\tint [] arr = new int [n];",
			"\t\t\tfor (int i = 0; i < arr.length; i++) {",
			"\t\t\t\tarr[i]=nextInt();",
			"\t\t\t}",
			"\t\t\treturn arr;",
			"\t\t}",
			"\t",
			"\t\tlong[] readArray(long []arr , int n) {",
			"\t",
			"\t\t\tfor (int i = 0; i < n; i++) {",
			"\t\t\t\tarr[i]=nextLong();",
			"\t\t\t}",
			"\t\treturn arr;",
			"\t\t}",
			"\t",
			"\t",
			"\t\tString nextLine()",
			"\t\t{",
			"\t\t\tString str = \"\";",
			"\t\t\ttry {",
			"\t\t\t\tstr = br.readLine();",
			"\t\t\t\t}",
			"\t\t\t\tcatch (IOException e) {",
			"\t\t\t\te.printStackTrace();",
			"\t\t\t}",
			"\t\t\treturn str;",
			"\t\t\t}",
			"\t}",
			"}"
		],
		"description" : "Template for Problem Solving"
	},
	"GCD":{
		"prefix": "GCD",
		"body": [
		"public static ${1|long,int|} gcd (${1|long,int|} a , ${1|long,int|} b)",
		"{",
		"\t\tif(a > b)",
		"\t\t{",
		"\t\t\t${1|long,int|} t = a;",
		"\t\t\ta = b;",
		"\t\t\tb = t;",
		"\t\t}",
		"\t\tif(a == (${1|long,int|})0)",
		"\t\t\treturn b;",
		"\t\treturn gcd(b%a, a);",
		"\t",
		"}"],
		"description": "GCD by Euclidean Method"
	},
	"BipartiteGraph":{
		"prefix":"isBipartiteGraph",
		"body" : [
			"public static boolean isBipartateGraph(ArrayList<ArrayList<Integer>> graph) {",
			"\tArrayDeque<Integer> bfs = new ArrayDeque<>();",
			"\tboolean [] visited = new boolean [graph.size()];",
			"\tboolean [] color = new boolean [graph.size()];",
			"\tfor(int node = 0 ; node<graph.size() ; node++)",
			"\t{",
			"\t\tif(visited[node]) continue;",
			"\t\tbfs.add(node);",
			"\t\twhile (!bfs.isEmpty()) {",
			"\t\tint current = bfs.removeFirst();",
			"\t\t\tfor(int adj : graph.get(current))",
			"\t\t\t{",
			"\t\t\t\tif(!visited[adj])",
			"\t\t\t\t{",
			"\t\t\t\t\tvisited[adj] = true;",
			"\t\t\t\t\tcolor[adj] = !color[current];",
			"\t\t\t\t\tbfs.add(adj);",
			"\t\t\t\t}",
			"\t\t\t\telse if(color[current] == color[adj]) return false;",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\treturn true;",
			"}"
		],
		"description" :"Checks if the graph is Bipartate or not"
	}
}